<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Gravar Consulta Médica</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .page {
      width: 100%;
      max-width: 800px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 20px 0 10px 0;
      text-align: center;
    }
    .center-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 30px 20px 25px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      margin-top: 10px;
    }
    #recordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #recordBtn.start {
      background: #28a745;
    }
    #recordBtn.recording {
      background: #dc3545;
    }
    #recordBtn:active {
      transform: scale(0.97);
    }
    #timer {
      font-size: 26px;
      margin-top: 16px;
      font-family: "Courier New", monospace;
    }
    #micStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    .controls-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #pauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #pauseLabel {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
      text-align: center;
    }
    #finishHint {
      font-size: 12px;
      color: #555;
      margin-top: 10px;
      text-align: center;
    }
    .results-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .results-card h2 {
      margin-top: 0;
    }

    /* GRID DO SOAP (S, O, A, P) */
    .soap-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 10px;
    }
    .soap-box {
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fafafa;
      padding: 8px;
      display: flex;
      flex-direction: column;
    }
    .soap-label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .soap-content {
      font-size: 14px;
      min-height: 60px;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background: #ffffff;
      white-space: pre-wrap;
    }
    .soap-content[contenteditable="true"]:focus {
      outline: 2px solid #0c5460;
    }

    /* BLOCO EDITÁVEL GENÉRICO (prescrição e orientações) */
    .editable-block {
      white-space: pre-wrap;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
      background: #fafafa;
      min-height: 80px;
      font-size: 14px;
    }
    .editable-block[contenteditable="true"]:focus {
      outline: 2px solid #0c5460;
      background: #ffffff;
    }

    pre {
      white-space: pre-wrap;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
      background: #fafafa;
      min-height: 80px;
      font-size: 14px;
    }
    #printBtn {
      margin-top: 12px;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      display: none;
    }
    .error {
      color: #b00020;
      margin-top: 8px;
      font-size: 13px;
      text-align: center;
    }
    .loading-dot::after {
      content: "...";
      animation: dots 1s steps(3, end) infinite;
    }
    @keyframes dots {
      0% { content: ""; }
      33% { content: "."; }
      66% { content: ".."; }
      100% { content: "..."; }
    }
    .missing-btn {
      border-radius: 12px;
      border: 1px solid #b00020;
      background: #fff0f0;
      color: #b00020;
      font-size: 12px;
      padding: 2px 6px;
      cursor: pointer;
      display: inline-block;
      margin: 0 2px;
    }
    .missing-explainer {
      font-size: 12px;
      color: #555;
      margin-top: 8px;
    }

    /* Painel lateral de recomendações de perguntas */
    .recommendations-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 360px;
      max-width: 100%;
      height: 100vh;
      background: #ffffff;
      box-shadow: -2px 0 8px rgba(0,0,0,0.15);
      display: none;
      flex-direction: column;
      padding: 16px;
      z-index: 1000;
    }
    .recommendations-panel.visible {
      display: flex;
    }
    .recommendations-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .recommendations-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .close-panel-btn {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .recommendations-status {
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
    }
    .recommendations-list {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .recommendation-item {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 6px;
    }
    .ask-questions-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      font-size: 14px;
    }
    .ask-questions-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .recommendations-footer {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }
    #recommendationsBtn {
      margin-left: 8px;
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      cursor: pointer;
      font-size: 14px;
    }
    #recommendationsBtn:hover {
      background: #e6f2f5;
    }

    @media (max-width: 480px) {
      #recordBtn {
        width: 150px;
        height: 150px;
        font-size: 18px;
      }
    }

    @media print {
      body {
        background: #ffffff;
      }
      .page {
        display: none;
      }
      #printArea {
        display: block !important;
      }
    }
    #printArea {
      display: none;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>Gravar Consulta Médica</h1>

    <div class="center-card">
      <button id="recordBtn" class="start">Iniciar consulta</button>

      <div id="timer">00:00</div>
      <div id="micStatus">Clique em "Iniciar consulta" para começar.</div>

      <div class="controls-row">
        <button id="pauseBtn">Pausar</button>
      </div>
      <div id="pauseLabel">Use o botão pequeno para pausar e retomar a consulta.</div>

      <div id="finishHint">
        Para encerrar a consulta e gerar o resumo SOAP, clique novamente no botão grande vermelho.
      </div>

      <div id="soapError" class="error"></div>
    </div>

    <div id="resultsCard" class="results-card hidden">
      <h2>Resumo SOAP</h2>

      <!-- QUATRO BLOCOS EDITÁVEIS: S, O, A, P -->
      <div id="soapOutput" class="soap-grid">
        <div class="soap-box">
          <div class="soap-label">S</div>
          <div id="soapS" class="soap-content" contenteditable="true"></div>
        </div>
        <div class="soap-box">
          <div class="soap-label">O</div>
          <div id="soapO" class="soap-content" contenteditable="true"></div>
        </div>
        <div class="soap-box">
          <div class="soap-label">A</div>
          <div id="soapA" class="soap-content" contenteditable="true"></div>
        </div>
        <div class="soap-box">
          <div class="soap-label">P</div>
          <div id="soapP" class="soap-content" contenteditable="true"></div>
        </div>
      </div>

      <div class="missing-explainer" id="missingExplainer" style="display:none;">
        Campos marcados como <strong>não informado</strong> aparecem com um botão.
        Clique nesses botões para perguntar ao paciente e atualizar o resumo automaticamente.
      </div>

      <h2>Prescrição</h2>
      <!-- PRESCRIÇÃO EDITÁVEL -->
      <div id="prescriptionOutput" class="editable-block" contenteditable="true"></div>

      <h2>Tratamento não farmacológico / Orientações</h2>
      <!-- ORIENTAÇÕES EDITÁVEIS -->
      <div id="orientacoesOutput" class="editable-block" contenteditable="true"></div>

      <button id="printBtn">Imprimir prescrição</button>
      <button id="recommendationsBtn">Recomendações de perguntas</button>
    </div>

    <!-- ÁREA DE IMPRESSÃO (PDF) -->
    <div id="printArea" class="hidden">
      <h2>Prescrição</h2>
      <pre id="prescricaoPrint"></pre>
      <h3>Tratamento não farmacológico / Orientações</h3>
      <pre id="orientacoesPrint"></pre>
    </div>
  </div>

  <!-- Painel lateral de recomendações -->
  <div id="recommendationsPanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Perguntas essenciais para anamnese</h3>
      <button id="closeRecommendationsBtn" class="close-panel-btn" aria-label="Fechar painel de recomendações">X</button>
    </div>
    <div id="recommendationsStatus" class="recommendations-status">
      Clique em "Recomendações de perguntas" para gerar perguntas complementares essenciais.
    </div>
    <div id="recommendationsList" class="recommendations-list"></div>
    <button id="askQuestionsBtn" class="ask-questions-btn" disabled>Fazer perguntas</button>
    <p class="recommendations-footer">
      Ao clicar em "Fazer perguntas", uma nova gravação será iniciada para você aplicar essas perguntas diretamente ao paciente.
      As respostas serão usadas para atualizar automaticamente o resumo SOAP e a conduta.
    </p>
  </div>

  <script>
    const BACKEND_URL = "https://consulta-medica-gravacao.onrender.com";

    let recognition;
    let isRecording = false;
    let isPaused = false;
    let finalTranscript = "";
    let baseTranscript = "";
    let timerInterval = null;
    let startTime = null;
    let accumulatedSeconds = 0;
    let currentSoapRaw = "";

    const recordBtn = document.getElementById("recordBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const timerEl = document.getElementById("timer");
    const micStatus = document.getElementById("micStatus");

    const soapOutput = document.getElementById("soapOutput");
    const soapS = document.getElementById("soapS");
    const soapO = document.getElementById("soapO");
    const soapA = document.getElementById("soapA");
    const soapP = document.getElementById("soapP");

    const prescriptionOutput = document.getElementById("prescriptionOutput");
    const orientacoesOutput = document.getElementById("orientacoesOutput");

    const resultsCard = document.getElementById("resultsCard");
    const soapError = document.getElementById("soapError");
    const printBtn = document.getElementById("printBtn");
    const prescricaoPrint = document.getElementById("prescricaoPrint");
    const printArea = document.getElementById("printArea");
    const orientacoesPrint = document.getElementById("orientacoesPrint");
    const missingExplainer = document.getElementById("missingExplainer");

    const recommendationsBtn = document.getElementById("recommendationsBtn");
    const recommendationsPanel = document.getElementById("recommendationsPanel");
    const closeRecommendationsBtn = document.getElementById("closeRecommendationsBtn");
    const recommendationsStatus = document.getElementById("recommendationsStatus");
    const recommendationsList = document.getElementById("recommendationsList");
    const askQuestionsBtn = document.getElementById("askQuestionsBtn");

    function initSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        micStatus.innerText =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      recognition = new SR();
      recognition.lang = "pt-BR";
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        let interimTranscript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interimTranscript += transcript;
          }
        }
      };

      recognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz:", event.error);
        if (event.error === "not-allowed" || event.error === "service-not-allowed") {
          micStatus.innerText =
            "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
        } else {
          micStatus.innerText =
            "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
        }
      };

      recognition.onend = () => {
        if (isRecording && !isPaused) {
          try {
            recognition.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento:", err);
          }
        }
      };
    }

    function updateTimer() {
      const now = Date.now();
      const seconds = accumulatedSeconds + Math.floor((now - startTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      timerEl.innerText = `${m}:${s}`;
    }

    function startTimer() {
      startTime = Date.now();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 500);
    }

    function pauseTimer() {
      if (!startTime) return;
      const now = Date.now();
      accumulatedSeconds += Math.floor((now - startTime) / 1000);
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function resetTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      startTime = null;
      accumulatedSeconds = 0;
      timerEl.innerText = "00:00";
    }

    async function finalizarConsulta() {
      soapError.textContent = "";
      micStatus.innerText = "Gerando resumo SOAP e prescrição com base na gravação...";
      micStatus.classList.add("loading-dot");

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }

      pauseTimer();

      const transcricao = finalTranscript.trim();
      if (!transcricao) {
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Nenhuma fala foi capturada. Verifique o microfone e tente novamente.";
        return;
      }

      baseTranscript = transcricao;

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent =
            "Erro ao gerar SOAP/prescrição. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "Nenhum texto de SOAP retornado.";
        const prescricao = data.prescricao || "Nenhum texto de prescrição retornado.";

        currentSoapRaw = soap;
        renderSoapWithMissing(currentSoapRaw);

        prescriptionOutput.textContent = prescricao;
        prescricaoPrint.textContent = prescricao;
        printBtn.style.display = "inline-block";

        micStatus.innerText = "Consulta encerrada. Resumo e prescrição gerados.";
        micStatus.classList.remove("loading-dot");
      } catch (e) {
        console.error(e);
        soapError.textContent =
          "Erro ao gerar SOAP e prescrição (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function splitSoapSections(soapText) {
      const sections = { S: "", O: "", A: "", P: "" };
      if (!soapText) return sections;

      const regex = /(^|\n)\s*([SOAP])\s*[:\-]\s*/g;
      let lastKey = null;
      let lastIndex = 0;
      let match;

      while ((match = regex.exec(soapText)) !== null) {
        if (lastKey) {
          sections[lastKey] = soapText.slice(lastIndex, match.index).trim();
        }
        lastKey = match[2];
        lastIndex = regex.lastIndex;
      }

      if (lastKey) {
        sections[lastKey] = soapText.slice(lastIndex).trim();
      } else {
        sections.S = soapText.trim();
      }

      return sections;
    }

    function renderSoapWithMissing(soapText) {
      const sections = splitSoapSections(soapText || "");

      if (!sections.S && !sections.O && !sections.A && !sections.P) {
        if (soapS) soapS.textContent = "";
        if (soapO) soapO.textContent = "";
        if (soapA) soapA.textContent = "";
        if (soapP) soapP.textContent = "";
        missingExplainer.style.display = "none";
        return;
      }

      let indexCounter = 0;

      function renderSection(text) {
        if (!text) return "";
        const escaped = escapeHtml(text);
        return escaped.replace(/não informado/gi, () => {
          indexCounter++;
          const contextSnippet = "campo " + indexCounter;
          return (
            '<button class="missing-btn" data-context="' +
            escapeHtml(contextSnippet) +
            '">não informado</button>'
          );
        });
      }

      if (soapS) soapS.innerHTML = renderSection(sections.S);
      if (soapO) soapO.innerHTML = renderSection(sections.O);
      if (soapA) soapA.innerHTML = renderSection(sections.A);
      if (soapP) soapP.innerHTML = renderSection(sections.P);

      resultsCard.classList.remove("hidden");
      missingExplainer.style.display = indexCounter > 0 ? "block" : "none";
    }

    function captureAdditionalInfo() {
      return new Promise((resolve) => {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) {
          const manual = prompt(
            "Seu navegador não suporta voz. Digite a informação adicional:"
          );
          resolve(manual ? manual.trim() : "");
          return;
        }

        const rec = new SR();
        rec.lang = "pt-BR";
        rec.continuous = false;
        rec.interimResults = true;

        let finalText = "";
        let interim = "";

        rec.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalText += transcript + " ";
            } else {
              interim += transcript;
            }
          }
        };

        rec.onerror = (e) => {
          console.error("Erro em captura adicional:", e.error);
          try { rec.stop(); } catch (err) {}
          resolve((finalText + " " + interim).trim());
        };

        rec.onend = () => {
          resolve((finalText + " " + interim).trim());
        };

        try {
          rec.start();
        } catch (err) {
          console.error("Erro ao iniciar captura adicional:", err);
          resolve("");
        }
      });
    }

    async function handleMissingClick(contextSnippet) {
      soapError.textContent = "";
      micStatus.innerText =
        "Gravando complemento para: " +
        (contextSnippet || "campo não informado") +
        ". Pergunte ao paciente e aguarde a resposta.";
      micStatus.classList.add("loading-dot");

      const extra = await captureAdditionalInfo();

      if (!extra) {
        micStatus.innerText = "Nenhuma informação adicional capturada.";
        micStatus.classList.remove("loading-dot");
        return;
      }

      finalTranscript =
        (baseTranscript || "") +
        `\n\nINFORMAÇÃO ADICIONAL SOBRE: ${
          contextSnippet || "campo não informado"
        }\nRESPOSTA do paciente/médico: ${extra}\n`;
      baseTranscript = finalTranscript;

      micStatus.innerText = "Atualizando resumo SOAP com a nova informação...";
      micStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: finalTranscript })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (complemento):", resp.status, txt);
          soapError.textContent =
            "Erro ao atualizar o SOAP com a informação adicional.";
          micStatus.innerText = "Falha ao atualizar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        currentSoapRaw = soap;
        renderSoapWithMissing(currentSoapRaw);

        if (prescricao) {
          prescriptionOutput.textContent = prescricao;
          prescricaoPrint.textContent = prescricao;
          printBtn.style.display = "inline-block";
        }

        micStatus.innerText =
          "Resumo SOAP atualizado com a nova informação.";
        micStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro geral ao atualizar SOAP com complemento:", err);
        soapError.textContent =
          "Erro ao atualizar o SOAP com a informação adicional.";
        micStatus.innerText = "Falha ao atualizar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    async function fetchRecommendations() {
      if (!currentSoapRaw || !currentSoapRaw.trim()) {
        soapError.textContent =
          "Não há SOAP gerado ainda para sugerir perguntas complementares.";
        return;
      }

      recommendationsPanel.classList.add("visible");
      recommendationsStatus.textContent =
        "Gerando perguntas complementares essenciais com base na queixa e no SOAP...";
      recommendationsStatus.classList.add("loading-dot");
      recommendationsList.innerHTML = "";
      askQuestionsBtn.disabled = true;

      try {
        const resp = await fetch(BACKEND_URL + "/api/recomendacoes-anamnese", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap: currentSoapRaw
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error(
            "Erro HTTP do backend (recomendações):",
            resp.status,
            txt
          );
          recommendationsStatus.textContent =
            "Não foi possível gerar as recomendações de perguntas.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const perguntas = Array.isArray(data.perguntas) ? data.perguntas : [];

        if (!perguntas.length) {
          recommendationsStatus.textContent =
            "Nenhuma pergunta complementar foi sugerida para este caso.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        recommendationsList.innerHTML = "";
        perguntas.forEach((q, index) => {
          const item = document.createElement("div");
          item.className = "recommendation-item";
          item.textContent = (index + 1) + ". " + q;
          recommendationsList.appendChild(item);
        });

        recommendationsStatus.textContent =
          "Use estas perguntas para aprofundar a anamnese com o paciente.";
        recommendationsStatus.classList.remove("loading-dot");
        askQuestionsBtn.disabled = false;
      } catch (err) {
        console.error("Erro geral ao buscar recomendações:", err);
        recommendationsStatus.textContent =
          "Erro ao gerar recomendações de perguntas.";
        recommendationsStatus.classList.remove("loading-dot");
      }
    }

    async function handleAskQuestionsFromPanel() {
      if (!baseTranscript && !finalTranscript) {
        baseTranscript = currentSoapRaw || "";
      }

      soapError.textContent = "";
      micStatus.innerText =
        "Gravando nova rodada de perguntas essenciais da anamnese. Faça as perguntas sugeridas e aguarde as respostas do paciente.";
      micStatus.classList.add("loading-dot");

      const extra = await captureAdditionalInfo();

      if (!extra) {
        micStatus.innerText = "Nenhuma informação adicional capturada.";
        micStatus.classList.remove("loading-dot");
        return;
      }

      finalTranscript =
        (baseTranscript || "") +
        "\n\nCOMPLEMENTO DE ANAMNESE (perguntas essenciais sugeridas):\n" +
        extra +
        "\n";
      baseTranscript = finalTranscript;

      micStatus.innerText =
        "Atualizando resumo SOAP com as novas informações obtidas na anamnese...";
      micStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: finalTranscript })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error(
            "Erro HTTP do backend (perguntas essenciais):",
            resp.status,
            txt
          );
          soapError.textContent =
            "Erro ao atualizar o SOAP com as informações das perguntas essenciais.";
          micStatus.innerText = "Falha ao atualizar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        currentSoapRaw = soap;
        renderSoapWithMissing(currentSoapRaw);

        if (prescricao) {
          prescriptionOutput.textContent = prescricao;
          prescricaoPrint.textContent = prescricao;
          printBtn.style.display = "inline-block";
        }

        micStatus.innerText =
          "Resumo SOAP atualizado com as respostas das perguntas essenciais.";
        micStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error(
          "Erro geral ao atualizar SOAP com perguntas essenciais:",
          err
        );
        soapError.textContent =
          "Erro ao atualizar o SOAP com as informações das perguntas essenciais.";
        micStatus.innerText = "Falha ao atualizar o resumo.";
        micStatus.classList.remove("loading-dot");
      } finally {
        recommendationsPanel.classList.remove("visible");
      }
    }

    function startRecording() {
      if (!recognition) {
        initSpeech();
        if (!recognition) {
          return;
        }
      }

      isRecording = true;
      isPaused = false;
      finalTranscript = "";
      baseTranscript = "";
      resultsCard.classList.add("hidden");
      printBtn.style.display = "none";

      prescriptionOutput.textContent = "";
      prescricaoPrint.textContent = "";
      orientacoesOutput.textContent = "";
      orientacoesPrint.textContent = "";

      if (soapS) soapS.textContent = "";
      if (soapO) soapO.textContent = "";
      if (soapA) soapA.textContent = "";
      if (soapP) soapP.textContent = "";

      missingExplainer.style.display = "none";

      pauseBtn.style.display = "inline-block";
      pauseBtn.innerText = "Pausar";
      recordBtn.className = "recording";
      recordBtn.innerText = "Encerrar consulta";
      micStatus.innerText = "Gravando consulta...";
      soapError.textContent = "";
      resultsCard.classList.add("hidden");

      resetTimer();
      startTimer();

      try {
        recognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento:", e);
      }
    }

    function stopRecording() {
      isRecording = false;
      isPaused = false;
      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }
      pauseTimer();
      recordBtn.className = "start";
      recordBtn.innerText = "Iniciar consulta";
      pauseBtn.style.display = "none";
    }

    function pauseRecording() {
      if (!isRecording || isPaused) return;
      isPaused = true;
      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao pausar reconhecimento:", e);
        }
      }
      pauseTimer();
      pauseBtn.innerText = "Retomar";
      micStatus.innerText = "Consulta pausada.";
    }

    function resumeRecording() {
      if (!isRecording || !isPaused) return;
      isPaused = false;
      if (recognition) {
        try {
          recognition.start();
        } catch (e) {
          console.warn("Erro ao retomar reconhecimento:", e);
        }
      }
      startTimer();
      pauseBtn.innerText = "Pausar";
      micStatus.innerText = "Gravando consulta...";
    }

    recordBtn.onclick = () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
        finalizarConsulta();
      }
    };

    pauseBtn.onclick = () => {
      if (!isRecording) return;
      if (!isPaused) {
        pauseRecording();
      } else {
        resumeRecording();
      }
    };

    printBtn.onclick = () => {
      const prescText = (prescriptionOutput.textContent || "").trim();
      const orientText = (orientacoesOutput.textContent || "").trim();

      if (!prescText) {
        alert("Não há prescrição para imprimir.");
        return;
      }

      prescricaoPrint.textContent = prescText;
      orientacoesPrint.textContent = orientText;

      printArea.classList.remove("hidden");
      window.print();
      setTimeout(() => {
        printArea.classList.add("hidden");
      }, 500);
    };

    recommendationsBtn.addEventListener("click", () => {
      fetchRecommendations();
    });

    closeRecommendationsBtn.addEventListener("click", () => {
      recommendationsPanel.classList.remove("visible");
    });

    askQuestionsBtn.addEventListener("click", () => {
      handleAskQuestionsFromPanel();
    });

    soapOutput.addEventListener("click", (e) => {
      const target = e.target;
      if (target && target.classList.contains("missing-btn")) {
        const context = target.getAttribute("data-context") || "";
        handleMissingClick(context);
      }
    });
  </script>
</body>
</html>
