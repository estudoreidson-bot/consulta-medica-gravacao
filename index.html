<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Gravar Consulta Médica</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .container {
      max-width: 1100px;
      width: 100%;
      padding: 20px;
      display: flex;
      gap: 20px;
    }
    h1 {
      margin: 20px 0 10px 0;
      text-align: center;
    }
    .center-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 30px 20px 25px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      margin-top: 10px;
    }
    .title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 16px;
      text-align: center;
    }
    .mic-status {
      margin-top: 10px;
      text-align: center;
      color: #555;
      min-height: 24px;
    }
    .loading-dot::after {
      content: "";
      display: inline-block;
      width: 6px;
      height: 6px;
      margin-left: 4px;
      border-radius: 50%;
      background: #007bff;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.4; }
      100% { transform: scale(1); opacity: 1; }
    }
    .record-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      border: none;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      background: #dc3545;
      color: #fff;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #recordBtn.start {
      background: #28a745;
    }
    #recordBtn.recording {
      background: #dc3545;
    }
    #recordBtn:active {
      transform: scale(0.97);
    }
    #timer {
      font-size: 26px;
      margin-bottom: 8px;
      font-weight: bold;
    }
    .pause-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    #pauseBtn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: #ffc107;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #pauseLabel {
      font-size: 13px;
      color: #666;
      max-width: 260px;
    }
    #finishHint {
      font-size: 13px;
      color: #666;
      margin-top: 6px;
      margin-bottom: 5px;
      text-align: center;
    }
    .error {
      color: #c00;
      font-size: 13px;
      margin-top: 8px;
      text-align: center;
    }
    .results-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 16px 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 12px;
      width: 100%;
      max-width: 420px;
    }
    .results-card h2 {
      margin-top: 0;
    }
    .soap-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-bottom: 10px;
    }
    .soap-box {
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fafafa;
      padding: 8px;
      display: flex;
      flex-direction: column;
    }
    .soap-label {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .soap-content {
      font-size: 14px;
      white-space: pre-wrap;
    }
    .patient-field {
      margin: 8px 0;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .patient-field input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 14px;
    }
    #prescriptionOutput {
      width: 100%;
      min-height: 120px;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
      box-sizing: border-box;
    }
    pre {
      white-space: pre-wrap;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
      background: #fafafa;
      min-height: 80px;
      font-size: 14px;
    }
    #printBtn {
      margin-top: 12px;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c54b5;
      color: #fff;
      font-weight: bold;
    }
    #recommendationsBtn {
      margin-top: 8px;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-weight: normal;
    }
    .hidden {
      display: none;
    }
    .missing-explainer {
      font-size: 12px;
      margin-top: 8px;
      color: #444;
    }
    .missing-btn {
      background: #ffeeba;
      border: 1px solid #ffc107;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
      margin: 0 2px;
    }
    .missing-btn:hover {
      background: #ffdf7e;
    }
    #printArea {
      display: none;
    }
    @media print {
      body * {
        visibility: hidden;
      }
      #printArea, #printArea * {
        visibility: visible;
      }
      #printArea {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        padding: 20px;
        background: #fff;
      }
    }

    .recommendations-panel {
      width: 360px;
      background: #ffffff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 10px;
      align-self: flex-start;
    }
    .recommendations-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .recommendations-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .recommendations-header button {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 18px;
    }
    .recommendations-status {
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
    }
    .recommendations-list {
      list-style: none;
      padding-left: 18px;
      font-size: 14px;
      max-height: 280px;
      overflow-y: auto;
    }
    .recommendations-list li {
      margin-bottom: 6px;
    }
    .questions-controls {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .questions-controls button {
      padding: 8px 12px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c54b5;
      color: #fff;
      font-size: 14px;
    }
    .questions-timer {
      font-size: 13px;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
      <h1>Gravação de Consulta</h1>
      <div class="center-card">
        <div class="title">Clique para iniciar ou encerrar a consulta</div>

        <div id="timer">00:00</div>

        <button id="recordBtn" class="record-btn start">
          Iniciar consulta
        </button>

        <div class="pause-container">
          <button id="pauseBtn" title="Pausar/Retomar">II</button>
          <div id="pauseLabel">Use o botão pequeno para pausar e retomar a consulta.</div>
        </div>

        <div id="finishHint">
          Para encerrar a consulta e gerar o resumo SOAP, clique novamente no botão grande vermelho.
        </div>

        <div id="soapError" class="error"></div>

        <div id="micStatus" class="mic-status">
          Aguardando início da gravação.
        </div>
      </div>

      <div id="resultsCard" class="results-card hidden">
        <h2>Resumo SOAP</h2>
        <div id="soapOutput" class="soap-grid">
          <div class="soap-box">
            <div class="soap-label">S</div>
            <div id="soapS" class="soap-content"></div>
          </div>
          <div class="soap-box">
            <div class="soap-label">O</div>
            <div id="soapO" class="soap-content"></div>
          </div>
          <div class="soap-box">
            <div class="soap-label">A</div>
            <div id="soapA" class="soap-content"></div>
          </div>
          <div class="soap-box">
            <div class="soap-label">P</div>
            <div id="soapP" class="soap-content"></div>
          </div>
        </div>
        <div class="missing-explainer" id="missingExplainer" style="display:none;">
          Campos marcados como <strong>não informado</strong> aparecem com um botão.
          Clique para falar ou digitar a informação faltante e atualizar o texto.
        </div>

        <h2>Prescrição</h2>
        <div class="patient-field">
          <label for="patientName">Paciente:</label>
          <input type="text" id="patientName" placeholder="Nome completo do paciente" />
        </div>
        <textarea id="prescriptionOutput"></textarea>

        <button id="printBtn">Imprimir prescrição</button>
        <button id="recommendationsBtn">Recomendações de perguntas</button>
      </div>

      <div id="printArea" class="hidden">
        <h2>Prescrição</h2>
        <p id="printPatientName"></p>
        <pre id="prescricaoPrint"></pre>
      </div>
    </div>

    <!-- Painel lateral de recomendações -->
    <div id="recommendationsPanel" class="recommendations-panel">
      <div class="recommendations-header">
        <h3>Perguntas essenciais da anamnese</h3>
        <button id="closeRecommendationsBtn" title="Fechar painel">×</button>
      </div>
      <div class="recommendations-status" id="recommendationsStatus">
        Clique em "Recomendações de perguntas" após gerar o SOAP
        para ver sugestões de perguntas importantes.
      </div>
      <ul class="recommendations-list" id="recommendationsList"></ul>
      <div class="questions-controls">
        <button id="askQuestionsBtn" disabled>Fazer perguntas</button>
        <div class="questions-timer">
          Tempo de perguntas: <span id="questionsTimer">00:00</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    let recognition = null;
    let finalTranscript = "";
    let isRecording = false;

    let startTime = null;
    let accumulatedSeconds = 0;
    let timerInterval = null;

    let isPaused = false;

    let currentSoapRaw = "";

    let isAskingQuestions = false;
    let questionsRecognition = null;
    let questionsTranscript = "";
    let questionsStartTime = null;
    let questionsAccumulatedSeconds = 0;
    let questionsTimerInterval = null;

    const micStatus = document.getElementById("micStatus");
    const soapOutput = document.getElementById("soapOutput");
    const soapS = document.getElementById("soapS");
    const soapO = document.getElementById("soapO");
    const soapA = document.getElementById("soapA");
    const soapP = document.getElementById("soapP");
    const prescriptionOutput = document.getElementById("prescriptionOutput");
    const patientNameInput = document.getElementById("patientName");
    const resultsCard = document.getElementById("resultsCard");
    const soapError = document.getElementById("soapError");
    const printBtn = document.getElementById("printBtn");
    const prescricaoPrint = document.getElementById("prescricaoPrint");
    const printArea = document.getElementById("printArea");
    const printPatientName = document.getElementById("printPatientName");
    const missingExplainer = document.getElementById("missingExplainer");

    const recommendationsBtn = document.getElementById("recommendationsBtn");
    const recommendationsPanel = document.getElementById("recommendationsPanel");
    const closeRecommendationsBtn = document.getElementById("closeRecommendationsBtn");
    const recommendationsStatus = document.getElementById("recommendationsStatus");
    const recommendationsList = document.getElementById("recommendationsList");
    const askQuestionsBtn = document.getElementById("askQuestionsBtn");

    function initSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        micStatus.innerText =
          "Seu navegador não suporta reconhecimento de voz. Use outro navegador.";
        return null;
      }
      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;
      return rec;
    }

    function formatTime(seconds) {
      const m = String(Math.floor(seconds / 60)).padStart(2, "0");
      const s = String(seconds % 60).padStart(2, "0");
      return `${m}:${s}`;
    }

    function startTimer() {
      if (timerInterval) return;
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 500);
    }

    function pauseTimer() {
      if (!startTime) return;
      const now = Date.now();
      accumulatedSeconds += Math.floor((now - startTime) / 1000);
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function resetTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      startTime = null;
      accumulatedSeconds = 0;
      document.getElementById("timer").innerText = "00:00";
    }

    function updateTimer() {
      if (!startTime) return;
      const now = Date.now();
      const elapsed = accumulatedSeconds + Math.floor((now - startTime) / 1000);
      document.getElementById("timer").innerText = formatTime(elapsed);
    }

    function togglePause() {
      if (!isRecording) return;
      if (!recognition) return;

      if (!isPaused) {
        isPaused = true;
        pauseTimer();
        micStatus.innerText = "Consulta pausada. Clique no botão pequeno para retomar.";
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao pausar reconhecimento:", e);
        }
      } else {
        isPaused = false;
        startTimer();
        micStatus.innerText = "Consulta retomada. Gravando...";
        recognition = initSpeech();
        if (!recognition) return;
        attachRecognitionEvents(recognition);
        try {
          recognition.start();
        } catch (e) {
          console.warn("Erro ao retomar reconhecimento:", e);
        }
      }
    }

    function attachRecognitionEvents(rec) {
      rec.onresult = (event) => {
        let interimTranscript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interimTranscript += transcript;
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento:", event.error);
        micStatus.innerText = "Erro no reconhecimento de voz: " + event.error;
      };

      rec.onend = () => {
        if (isRecording && !isPaused) {
          try {
            rec.start();
          } catch (e) {
            console.warn("Erro ao reiniciar reconhecimento:", e);
          }
        }
      };
    }

    const recordBtn = document.getElementById("recordBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    pauseBtn.addEventListener("click", () => {
      togglePause();
    });

    recordBtn.addEventListener("click", async () => {
      if (!isRecording) {
        finalTranscript = "";
        isRecording = true;
        isPaused = false;
        micStatus.classList.remove("loading-dot");
        micStatus.innerText = "Gravando consulta...";
        recordBtn.textContent = "Finalizar consulta";
        recordBtn.classList.remove("start");
        recordBtn.classList.add("recording");
        soapError.textContent = "";

        resetTimer();
        startTimer();

        resultsCard.classList.add("hidden");
        printBtn.style.display = "none";
        prescriptionOutput.value = "";
        prescricaoPrint.textContent = "";
        if (typeof soapS !== "undefined") soapS.textContent = "";
        if (typeof soapO !== "undefined") soapO.textContent = "";
        if (typeof soapA !== "undefined") soapA.textContent = "";
        if (typeof soapP !== "undefined") soapP.textContent = "";
        if (typeof patientNameInput !== "undefined" && patientNameInput) patientNameInput.value = "";
        if (typeof printPatientName !== "undefined" && printPatientName) printPatientName.textContent = "";
        missingExplainer.style.display = "none";

        recognition = initSpeech();
        if (!recognition) return;
        attachRecognitionEvents(recognition);

        try {
          recognition.start();
        } catch (e) {
          console.error("Erro ao iniciar reconhecimento:", e);
          micStatus.innerText = "Erro ao iniciar reconhecimento de voz.";
          isRecording = false;
          recordBtn.textContent = "Iniciar consulta";
          recordBtn.classList.remove("recording");
          recordBtn.classList.add("start");
        }
      } else {
        isRecording = false;
        pauseTimer();
        micStatus.classList.add("loading-dot");
        micStatus.innerText =
          "Gerando resumo SOAP e prescrição com base na gravação...";

        if (recognition) {
          try {
            recognition.stop();
          } catch (e) {
            console.warn("Erro ao parar reconhecimento:", e);
          }
        }

        recordBtn.textContent = "Iniciar nova consulta";
        recordBtn.classList.remove("recording");
        recordBtn.classList.add("start");

        await finalizarConsulta();
      }
    });

    async function finalizarConsulta() {
      soapError.textContent = "";
      micStatus.innerText = "Gerando resumo SOAP e prescrição com base na gravação...";
      micStatus.classList.add("loading-dot");

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }

      pauseTimer();

      const transcricao = finalTranscript.trim();
      if (!transcricao) {
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Nenhuma fala foi capturada. Verifique o microfone e tente novamente.";
        soapError.textContent =
          "Não foi possível gerar o SOAP porque nenhuma fala foi detectada.";
        return;
      }

      try {
        const resp = await fetch("/api/gerar-soap", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ transcricao }),
        });

        if (!resp.ok) {
          const errorData = await resp.json().catch(() => ({}));
          const msg =
            errorData.error ||
            "Erro ao gerar SOAP. Tente novamente em instantes.";
          throw new Error(msg);
        }

        const data = await resp.json();
        const soap = data.soap || "Nenhum texto de SOAP retornado.";
        const prescricao = data.prescricao || "Nenhum texto de prescrição retornado.";

        currentSoapRaw = soap;
        renderSoapWithMissing(currentSoapRaw);
        prescriptionOutput.value = prescricao;
        prescricaoPrint.textContent = prescricao;
        printBtn.style.display = "inline-block";
        resultsCard.classList.remove("hidden");

        micStatus.classList.remove("loading-dot");
        micStatus.innerText = "Resumo SOAP e prescrição gerados com sucesso.";
      } catch (error) {
        console.error("Erro ao chamar /api/gerar-soap:", error);
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Ocorreu um erro ao gerar o SOAP. Veja detalhes abaixo.";
        soapError.textContent = String(error.message || error);
      }
    }

    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function splitSoapSections(soapText) {
      const sections = { S: "", O: "", A: "", P: "" };
      if (!soapText) {
        return sections;
      }

      const regex = /(^|\n)\s*([SOAP])\s*[:\-]\s*/g;
      let lastKey = null;
      let lastIndex = 0;
      let match;

      while ((match = regex.exec(soapText)) !== null) {
        if (lastKey) {
          sections[lastKey] = soapText.slice(lastIndex, match.index).trim();
        }
        lastKey = match[2];
        lastIndex = regex.lastIndex;
      }

      if (lastKey) {
        sections[lastKey] = soapText.slice(lastIndex).trim();
      } else {
        sections.S = soapText.trim();
      }

      return sections;
    }

    function renderSoapWithMissing(soapText) {
      const sections = splitSoapSections(soapText || "");

      if (!sections.S && !sections.O && !sections.A && !sections.P) {
        soapS.textContent = "";
        soapO.textContent = "";
        soapA.textContent = "";
        soapP.textContent = "";
        missingExplainer.style.display = "none";
        return;
      }

      let indexCounter = 0;

      function renderSection(text) {
        if (!text) return "";
        const escaped = escapeHtml(text);
        return escaped.replace(/não informado/gi, () => {
          indexCounter++;
          const contextSnippet = "campo " + indexCounter;
          return (
            '<button class="missing-btn" data-context="' +
            escapeHtml(contextSnippet) +
            '">não informado</button>'
          );
        });
      }

      soapS.innerHTML = renderSection(sections.S);
      soapO.innerHTML = renderSection(sections.O);
      soapA.innerHTML = renderSection(sections.A);
      soapP.innerHTML = renderSection(sections.P);

      resultsCard.classList.remove("hidden");
      missingExplainer.style.display = indexCounter > 0 ? "block" : "none";
    }

    // Captura rápida para campos "não informado"
    function captureAdditionalInfo() {
      return new Promise((resolve) => {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) {
          const manual = prompt(
            "Seu navegador não suporta voz. Digite a informação adicional:"
          );
          resolve(manual ? manual.trim() : "");
          return;
        }

        const rec = new SR();
        rec.lang = "pt-BR";
        rec.continuous = false;
        rec.interimResults = true;

        let finalText = "";
        let interim = "";

        rec.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalText += transcript + " ";
            } else {
              interim = transcript;
            }
          }
        };

        rec.onerror = (event) => {
          console.error("Erro no reconhecimento de voz (campo faltante):", event);
          rec.stop();
        };

        rec.onend = () => {
          const text = (finalText || interim || "").trim();
          if (!text) {
            const manual = prompt(
              "Nenhum áudio capturado. Digite manualmente a informação adicional:"
            );
            resolve(manual ? manual.trim() : "");
          } else {
            resolve(text);
          }
        };

        alert(
          "Fale agora a informação que está faltando para substituir 'não informado'. Clique em OK e comece a falar."
        );

        try {
          rec.start();
        } catch (e) {
          console.error("Erro ao iniciar reconhecimento (campo faltante):", e);
          const manual = prompt(
            "Não foi possível iniciar o reconhecimento de voz. Digite a informação adicional:"
          );
          resolve(manual ? manual.trim() : "");
        }
      });
    }

    async function handleMissingClick(context) {
      try {
        const newInfo = await captureAdditionalInfo();
        if (!newInfo) return;

        currentSoapRaw = currentSoapRaw.replace(/não informado/i, newInfo);
        renderSoapWithMissing(currentSoapRaw);
        micStatus.innerText =
          "Informação adicional incluída no resumo SOAP com sucesso.";
      } catch (error) {
        console.error("Erro ao capturar informação adicional:", error);
        micStatus.innerText =
          "Não foi possível incluir a informação adicional. Tente novamente.";
      }
    }

    printBtn.onclick = () => {
      const prescriptionText = (prescriptionOutput.value || "").trim();
      const patientName = (patientNameInput ? patientNameInput.value : "").trim();

      if (!prescriptionText) {
        alert("Não há prescrição para imprimir.");
        return;
      }

      if (!patientName) {
        const proceed = confirm(
          "O nome do paciente não foi preenchido. Deseja imprimir a prescrição mesmo assim?"
        );
        if (!proceed) return;
      }

      prescricaoPrint.textContent = prescriptionText;
      if (printPatientName) {
        printPatientName.textContent = patientName ? "Paciente: " + patientName : "";
      }

      printArea.classList.remove("hidden");
      window.print();
      setTimeout(() => {
        printArea.classList.add("hidden");
      }, 500);
    };

    function initRecommendationsPanel() {
      recommendationsStatus.innerText =
        "Clique em \"Recomendações de perguntas\" após gerar o SOAP para ver sugestões importantes de anamnese.";
      recommendationsList.innerHTML = "";
      askQuestionsBtn.disabled = true;
    }

    async function fetchRecommendations() {
      if (!currentSoapRaw || !currentSoapRaw.trim()) {
        alert("É necessário ter um SOAP gerado para pedir recomendações.");
        return;
      }

      recommendationsStatus.innerText = "Gerando recomendações de perguntas...";
      recommendationsList.innerHTML = "";
      askQuestionsBtn.disabled = true;

      const queixaPrincipal =
        (currentSoapRaw.match(/S[:\-](.*?)(?:\n|$)/i) || [null, ""])[1].trim() ||
        "";
      const historicoResumido =
        (currentSoapRaw.match(/O[:\-](.*?)(?:\n|$)/i) || [null, ""])[1].trim() ||
        "";

      try {
        const resp = await fetch("/api/recomendacoes-anamnese", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            queixaPrincipal,
            historicoResumido,
            soapAtual: currentSoapRaw,
          }),
        });

        if (!resp.ok) {
          const errorData = await resp.json().catch(() => ({}));
          const msg =
            errorData.error ||
            "Erro ao gerar recomendações. Tente novamente em instantes.";
          throw new Error(msg);
        }

        const data = await resp.json();
        const perguntas = Array.isArray(data.perguntas) ? data.perguntas : [];

        if (!perguntas.length) {
          recommendationsStatus.innerText =
            "Nenhuma pergunta adicional essencial foi identificada.";
          recommendationsList.innerHTML = "";
          askQuestionsBtn.disabled = true;
          return;
        }

        recommendationsStatus.innerText =
          "Perguntas sugeridas para complementar a anamnese:";
        recommendationsList.innerHTML = "";
        perguntas.forEach((p) => {
          const li = document.createElement("li");
          li.textContent = p;
          recommendationsList.appendChild(li);
        });

        askQuestionsBtn.disabled = false;
      } catch (err) {
        console.error("Erro em /api/recomendacoes-anamnese:", err);
        recommendationsStatus.innerText =
          "Ocorreu um erro ao gerar recomendações de anamnese.";
        recommendationsList.innerHTML = "";
        askQuestionsBtn.disabled = true;
      }
    }

    function startQuestionsTimer() {
      if (questionsTimerInterval) return;
      questionsStartTime = Date.now();
      questionsTimerInterval = setInterval(updateQuestionsTimer, 500);
    }

    function stopQuestionsTimer() {
      if (!questionsStartTime) return;
      const now = Date.now();
      questionsAccumulatedSeconds += Math.floor(
        (now - questionsStartTime) / 1000
      );
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
    }

    function resetQuestionsTimer() {
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
      questionsStartTime = null;
      questionsAccumulatedSeconds = 0;
      document.getElementById("questionsTimer").innerText = "00:00";
    }

    function updateQuestionsTimer() {
      if (!questionsStartTime) return;
      const now = Date.now();
      const elapsed =
        questionsAccumulatedSeconds +
        Math.floor((now - questionsStartTime) / 1000);
      document.getElementById("questionsTimer").innerText = formatTime(elapsed);
    }

    function initQuestionsRecognition() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        alert(
          "Seu navegador não suporta reconhecimento de voz para as perguntas adicionais."
        );
        return null;
      }
      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;
      return rec;
    }

    function attachQuestionsEvents(rec) {
      rec.onresult = (event) => {
        let interimTranscript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            questionsTranscript += transcript + " ";
          } else {
            interimTranscript += transcript;
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento (perguntas):", event.error);
      };

      rec.onend = () => {
        if (isAskingQuestions) {
          try {
            rec.start();
          } catch (e) {
            console.warn("Erro ao reiniciar reconhecimento (perguntas):", e);
          }
        }
      };
    }

    async function handleAskQuestionsFromPanel() {
      if (!currentSoapRaw || !currentSoapRaw.trim()) {
        alert("É necessário ter um SOAP gerado para fazer perguntas adicionais.");
        return;
      }

      if (!isAskingQuestions) {
        isAskingQuestions = true;
        questionsTranscript = "";
        resetQuestionsTimer();
        startQuestionsTimer();

        questionsRecognition = initQuestionsRecognition();
        if (!questionsRecognition) {
          isAskingQuestions = false;
          return;
        }
        attachQuestionsEvents(questionsRecognition);

        try {
          questionsRecognition.start();
          micStatus.innerText =
            "Fazendo perguntas adicionais ao paciente. Quando terminar, clique novamente no botão.";
          askQuestionsBtn.textContent = "Encerrar perguntas";
        } catch (e) {
          console.error("Erro ao iniciar reconhecimento (perguntas):", e);
          isAskingQuestions = false;
        }
      } else {
        isAskingQuestions = false;
        stopQuestionsTimer();
        if (questionsRecognition) {
          try {
            questionsRecognition.stop();
          } catch (e) {
            console.warn("Erro ao parar reconhecimento (perguntas):", e);
          }
        }

        micStatus.innerText =
          "Atualizando resumo SOAP com as novas respostas da anamnese...";
        micStatus.classList.add("loading-dot");

        const extra = (questionsTranscript || "").trim();
        questionsTranscript = "";

        if (!extra) {
          micStatus.innerText =
            "Nenhuma informação adicional capturada nas perguntas essenciais.";
          micStatus.classList.remove("loading-dot");
          askQuestionsBtn.textContent = "Fazer perguntas";
          return;
        }

        try {
          const novaTranscricao = (finalTranscript + " " + extra).trim();
          const resp = await fetch("/api/gerar-soap", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ transcricao: novaTranscricao }),
          });

          if (!resp.ok) {
            const errorData = await resp.json().catch(() => ({}));
            const msg =
              errorData.error ||
              "Erro ao atualizar SOAP com as novas informações.";
            throw new Error(msg);
          }

          const data = await resp.json();
          const soap = data.soap || "Nenhum texto de SOAP retornado.";
          const prescricao =
            data.prescricao || "Nenhum texto de prescrição retornado.";

          currentSoapRaw = soap;
          renderSoapWithMissing(currentSoapRaw);
          prescriptionOutput.value = prescricao;
          prescricaoPrint.textContent = prescricao;
          printBtn.style.display = "inline-block";
          resultsCard.classList.remove("hidden");

          micStatus.classList.remove("loading-dot");
          micStatus.innerText =
            "Resumo SOAP atualizado com as novas respostas da anamnese.";
        } catch (err) {
          console.error("Erro ao atualizar SOAP com perguntas:", err);
          micStatus.classList.remove("loading-dot");
          micStatus.innerText =
            "Ocorreu um erro ao atualizar o SOAP com as informações adicionais.";
        } finally {
          askQuestionsBtn.textContent = "Fazer perguntas";
        }
      }
    }

    recommendationsBtn.addEventListener("click", () => {
      fetchRecommendations();
    });

    closeRecommendationsBtn.addEventListener("click", () => {
      recommendationsPanel.style.display = "none";
    });

    askQuestionsBtn.addEventListener("click", () => {
      handleAskQuestionsFromPanel();
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === " ") {
        e.preventDefault();
        recordBtn.click();
      } else if (e.key === "p" || e.key === "P") {
        e.preventDefault();
        togglePause();
      } else if (e.key === "q" || e.key === "Q") {
        e.preventDefault();
        handleAskQuestionsFromPanel();
      }
    });

    soapOutput.addEventListener("click", (e) => {
      const target = e.target;
      if (target && target.classList.contains("missing-btn")) {
        const context = target.getAttribute("data-context") || "";
        handleMissingClick(context);
      }
    });

    initRecommendationsPanel();
  </script>
</body>
</html>
